package api

import (
	"testing"

	"github.com/fluxbase-eu/fluxbase/internal/database"
	"github.com/stretchr/testify/assert"
)

// =============================================================================
// GraphQLSchemaGenerator Construction Tests
// =============================================================================

func TestNewGraphQLSchemaGenerator(t *testing.T) {
	t.Run("creates generator with nil dependencies", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, true)
		assert.NotNil(t, gen)
		assert.True(t, gen.introspectionOn)
	})

	t.Run("creates generator with introspection off", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, false)
		assert.NotNil(t, gen)
		assert.False(t, gen.introspectionOn)
	})

	t.Run("maps are initialized", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, true)
		assert.NotNil(t, gen.objectTypes)
		assert.NotNil(t, gen.inputTypes)
		assert.NotNil(t, gen.filterTypes)
		assert.NotNil(t, gen.orderByTypes)
	})
}

// =============================================================================
// toPascalCase Tests
// =============================================================================

func TestToPascalCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"users", "Users"},
		{"user_profiles", "UserProfiles"},
		{"USER_PROFILES", "UserProfiles"},
		{"userProfiles", "Userprofiles"},
		{"my_long_table_name", "MyLongTableName"},
		{"id", "Id"},
		{"ID", "Id"},
		{"api_key", "ApiKey"},
		{"OAuth2Token", "Oauth2token"},
		{"", ""},
		{"a", "A"},
		{"_private", "Private"},
		{"table_1", "Table1"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := toPascalCase(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// toCamelCase Tests
// =============================================================================

func TestToCamelCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"users", "users"},
		{"user_profiles", "userProfiles"},
		{"USER_PROFILES", "userProfiles"},
		{"UserProfiles", "userprofiles"},
		{"my_long_table_name", "myLongTableName"},
		{"id", "id"},
		{"ID", "id"},
		{"api_key", "apiKey"},
		{"created_at", "createdAt"},
		{"", ""},
		{"a", "a"},
		{"_private", "private"},
		{"table_1", "table1"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := toCamelCase(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// splitWords Tests
// =============================================================================

func TestSplitWords(t *testing.T) {
	tests := []struct {
		input    string
		expected []string
	}{
		{"users", []string{"users"}},
		{"user_profiles", []string{"user", "profiles"}},
		{"userProfiles", []string{"user", "Profiles"}},
		{"user-profiles", []string{"user", "profiles"}},
		{"my_long_table_name", []string{"my", "long", "table", "name"}},
		{"camelCase", []string{"camel", "Case"}},
		{"CamelCase", []string{"Camel", "Case"}},
		{"ID", []string{"ID"}},
		{"userID", []string{"user", "ID"}},
		{"", nil},
		{"_private", []string{"private"}},
		{"__double__underscore__", []string{"double", "underscore"}},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := splitWords(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// isAutoGenerated Tests
// =============================================================================

func TestIsAutoGenerated(t *testing.T) {
	tests := []struct {
		name     string
		col      database.ColumnInfo
		expected bool
	}{
		{
			name: "no default value",
			col: database.ColumnInfo{
				Name:         "name",
				DefaultValue: nil,
			},
			expected: false,
		},
		{
			name: "serial nextval",
			col: database.ColumnInfo{
				Name:         "id",
				DefaultValue: ptr("nextval('users_id_seq'::regclass)"),
			},
			expected: true,
		},
		{
			name: "gen_random_uuid",
			col: database.ColumnInfo{
				Name:         "id",
				DefaultValue: ptr("gen_random_uuid()"),
			},
			expected: true,
		},
		{
			name: "uuid_generate_v4",
			col: database.ColumnInfo{
				Name:         "id",
				DefaultValue: ptr("uuid_generate_v4()"),
			},
			expected: true,
		},
		{
			name: "now() timestamp",
			col: database.ColumnInfo{
				Name:         "created_at",
				DefaultValue: ptr("now()"),
			},
			expected: true,
		},
		{
			name: "CURRENT_TIMESTAMP",
			col: database.ColumnInfo{
				Name:         "updated_at",
				DefaultValue: ptr("CURRENT_TIMESTAMP"),
			},
			expected: true,
		},
		{
			name: "string default",
			col: database.ColumnInfo{
				Name:         "status",
				DefaultValue: ptr("'pending'::text"),
			},
			expected: false,
		},
		{
			name: "numeric default",
			col: database.ColumnInfo{
				Name:         "count",
				DefaultValue: ptr("0"),
			},
			expected: false,
		},
		{
			name: "boolean default",
			col: database.ColumnInfo{
				Name:         "active",
				DefaultValue: ptr("true"),
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isAutoGenerated(tt.col)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// Helper function to create string pointer
func ptr(s string) *string {
	return &s
}

// =============================================================================
// postgresTypeToGraphQLInput Tests
// =============================================================================

func TestPostgresTypeToGraphQLInput(t *testing.T) {
	t.Run("string types", func(t *testing.T) {
		stringTypes := []string{"text", "varchar", "character varying", "char", "character", "name", "citext"}
		for _, pgType := range stringTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.NotNil(t, result)
		}
	})

	t.Run("integer types", func(t *testing.T) {
		intTypes := []string{"integer", "int", "int4", "smallint", "int2", "serial", "serial4"}
		for _, pgType := range intTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.NotNil(t, result)
		}
	})

	t.Run("bigint types", func(t *testing.T) {
		bigintTypes := []string{"bigint", "int8", "bigserial", "serial8"}
		for _, pgType := range bigintTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.Equal(t, BigIntScalar, result)
		}
	})

	t.Run("float types", func(t *testing.T) {
		floatTypes := []string{"real", "float4", "double precision", "float8", "numeric", "decimal", "money"}
		for _, pgType := range floatTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.NotNil(t, result)
		}
	})

	t.Run("boolean types", func(t *testing.T) {
		boolTypes := []string{"boolean", "bool"}
		for _, pgType := range boolTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.NotNil(t, result)
		}
	})

	t.Run("uuid type", func(t *testing.T) {
		result := postgresTypeToGraphQLInput("uuid")
		assert.Equal(t, UUIDScalar, result)
	})

	t.Run("json types", func(t *testing.T) {
		jsonTypes := []string{"json", "jsonb"}
		for _, pgType := range jsonTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.Equal(t, JSONScalar, result)
		}
	})

	t.Run("date/time types", func(t *testing.T) {
		dateTypes := []string{
			"timestamp", "timestamp without time zone", "timestamp with time zone", "timestamptz",
			"date", "time", "time without time zone", "time with time zone", "timetz", "interval",
		}
		for _, pgType := range dateTypes {
			result := postgresTypeToGraphQLInput(pgType)
			assert.Equal(t, DateTimeScalar, result)
		}
	})

	t.Run("unknown type defaults to string", func(t *testing.T) {
		result := postgresTypeToGraphQLInput("custom_enum")
		assert.NotNil(t, result)
	})
}

// =============================================================================
// InvalidateSchema Tests
// =============================================================================

func TestInvalidateSchema(t *testing.T) {
	t.Run("invalidates cached schema", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, true)

		// Calling InvalidateSchema should not panic
		assert.NotPanics(t, func() {
			gen.InvalidateSchema()
		})

		// Schema should be nil after invalidation
		assert.Nil(t, gen.schema)
	})
}

// =============================================================================
// SetResolverFactory Tests
// =============================================================================

func TestSetResolverFactory(t *testing.T) {
	t.Run("sets resolver factory", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, true)
		factory := NewGraphQLResolverFactory(nil, nil)

		gen.SetResolverFactory(factory)

		assert.Equal(t, factory, gen.resolverFactory)
	})

	t.Run("sets nil resolver factory", func(t *testing.T) {
		gen := NewGraphQLSchemaGenerator(nil, nil, true)

		gen.SetResolverFactory(nil)

		assert.Nil(t, gen.resolverFactory)
	})
}

// =============================================================================
// tableToTypeName Tests
// =============================================================================

func TestTableToTypeName(t *testing.T) {
	gen := NewGraphQLSchemaGenerator(nil, nil, true)

	tests := []struct {
		schema   string
		table    string
		expected string
	}{
		{"public", "users", "Users"},
		{"public", "user_profiles", "UserProfiles"},
		{"auth", "sessions", "Sessions"},
		{"public", "api_keys", "ApiKeys"},
	}

	for _, tt := range tests {
		t.Run(tt.table, func(t *testing.T) {
			result := gen.tableToTypeName(tt.schema, tt.table)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// tableToCollectionName Tests
// =============================================================================

func TestTableToCollectionName(t *testing.T) {
	gen := NewGraphQLSchemaGenerator(nil, nil, true)

	tests := []struct {
		table    string
		expected string
	}{
		{"users", "users"},
		{"user_profiles", "userProfiles"},
		{"Posts", "posts"},
		{"api_keys", "apiKeys"},
	}

	for _, tt := range tests {
		t.Run(tt.table, func(t *testing.T) {
			result := gen.tableToCollectionName(tt.table)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// tableToSingleName Tests
// =============================================================================

func TestTableToSingleName(t *testing.T) {
	gen := NewGraphQLSchemaGenerator(nil, nil, true)

	tests := []struct {
		table    string
		expected string
	}{
		{"users", "user"},
		{"posts", "post"},
		{"categories", "category"},
		{"addresses", "addresse"}, // Simple rule
		{"person", "person"},      // No trailing 's'
		{"news", "new"},           // Edge case
		{"s", ""},                 // Single 's'
	}

	for _, tt := range tests {
		t.Run(tt.table, func(t *testing.T) {
			result := gen.tableToSingleName(tt.table)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// columnToFieldName Tests
// =============================================================================

func TestColumnToFieldName(t *testing.T) {
	gen := NewGraphQLSchemaGenerator(nil, nil, true)

	tests := []struct {
		column   string
		expected string
	}{
		{"id", "id"},
		{"user_id", "userId"},
		{"created_at", "createdAt"},
		{"is_active", "isActive"},
		{"name", "name"},
	}

	for _, tt := range tests {
		t.Run(tt.column, func(t *testing.T) {
			result := gen.columnToFieldName(tt.column)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// =============================================================================
// fkToRelationName Tests
// =============================================================================

func TestFkToRelationName(t *testing.T) {
	gen := NewGraphQLSchemaGenerator(nil, nil, true)

	tests := []struct {
		fkColumn string
		expected string
	}{
		{"user_id", "user"},
		{"post_id", "post"},
		{"authorId", "author"},
		{"category", "category"}, // No _id suffix
		{"author_user_id", "authorUser"},
	}

	for _, tt := range tests {
		t.Run(tt.fkColumn, func(t *testing.T) {
			result := gen.fkToRelationName(tt.fkColumn)
			assert.Equal(t, tt.expected, result)
		})
	}
}

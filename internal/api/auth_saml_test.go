package api

import (
	"encoding/json"
	"net/http/httptest"
	"testing"

	"github.com/gofiber/fiber/v3"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestSAMLHandler_NoServiceConfigured tests all SAML endpoints when SAML service is not configured
// This tests the defensive programming aspects of the handlers
func TestSAMLHandler_NoServiceConfigured(t *testing.T) {
	tests := []struct {
		name           string
		method         string
		path           string
		expectedStatus int
		expectedError  string
	}{
		{
			name:           "list providers with no SAML service",
			method:         "GET",
			path:           "/auth/saml/providers",
			expectedStatus: fiber.StatusOK, // Returns empty array
		},
		{
			name:           "get metadata with no SAML service",
			method:         "GET",
			path:           "/auth/saml/metadata/okta",
			expectedStatus: fiber.StatusNotFound,
			expectedError:  "SAML is not configured",
		},
		{
			name:           "initiate login with no SAML service",
			method:         "GET",
			path:           "/auth/saml/login/okta",
			expectedStatus: fiber.StatusNotFound,
			expectedError:  "SAML is not configured",
		},
		{
			name:           "handle assertion with no SAML service",
			method:         "POST",
			path:           "/auth/saml/acs",
			expectedStatus: fiber.StatusNotFound,
			expectedError:  "SAML is not configured",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			app := fiber.New()
			handler := NewSAMLHandler(nil, nil)

			// Register routes based on path
			switch tt.path {
			case "/auth/saml/providers":
				app.Get(tt.path, handler.ListSAMLProviders)
			case "/auth/saml/metadata/okta":
				app.Get("/auth/saml/metadata/:provider", handler.GetSPMetadata)
			case "/auth/saml/login/okta":
				app.Get("/auth/saml/login/:provider", handler.InitiateSAMLLogin)
			case "/auth/saml/acs":
				app.Post(tt.path, handler.HandleSAMLAssertion)
			}

			req := httptest.NewRequest(tt.method, tt.path, nil)
			if tt.method == "GET" && tt.path == "/auth/saml/login/okta" {
				req.Header.Set("Accept", "application/json")
			}

			resp, err := app.Test(req)
			require.NoError(t, err)
			defer resp.Body.Close()

			assert.Equal(t, tt.expectedStatus, resp.StatusCode)

			if tt.expectedError != "" {
				var result map[string]interface{}
				err = json.NewDecoder(resp.Body).Decode(&result)
				require.NoError(t, err)
				assert.Contains(t, result["error"], tt.expectedError)
			}
		})
	}
}

// TestListSAMLProviders_ReturnsEmptyArray tests that an empty array is returned when no providers exist
func TestListSAMLProviders_ReturnsEmptyArray(t *testing.T) {
	app := fiber.New()
	handler := NewSAMLHandler(nil, nil)
	app.Get("/auth/saml/providers", handler.ListSAMLProviders)

	req := httptest.NewRequest("GET", "/auth/saml/providers", nil)
	resp, err := app.Test(req)
	require.NoError(t, err)
	defer resp.Body.Close()

	assert.Equal(t, fiber.StatusOK, resp.StatusCode)

	var result []SAMLProviderResponse
	err = json.NewDecoder(resp.Body).Decode(&result)
	require.NoError(t, err)
	assert.Equal(t, 0, len(result), "Should return empty array when SAML is not configured")
	assert.NotNil(t, result, "Should return empty array, not null")
}

// TestInitiateSAMLLogin_AcceptHeader tests that the Accept header determines response format
func TestInitiateSAMLLogin_AcceptHeader(t *testing.T) {
	tests := []struct {
		name         string
		acceptHeader string
	}{
		{
			name:         "JSON response when Accept is application/json",
			acceptHeader: "application/json",
		},
		{
			name:         "JSON response when Accept contains application/json",
			acceptHeader: "text/html,application/json;q=0.9",
		},
		{
			name:         "redirect when Accept is text/html",
			acceptHeader: "text/html",
		},
		{
			name:         "redirect when no Accept header",
			acceptHeader: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			app := fiber.New()
			handler := NewSAMLHandler(nil, nil)
			app.Get("/auth/saml/login/:provider", handler.InitiateSAMLLogin)

			req := httptest.NewRequest("GET", "/auth/saml/login/okta", nil)
			if tt.acceptHeader != "" {
				req.Header.Set("Accept", tt.acceptHeader)
			}

			resp, err := app.Test(req)
			require.NoError(t, err)
			defer resp.Body.Close()

			// Since SAML is not configured, should always return 404
			// But this tests that the Accept header logic runs before the auth logic
			assert.Equal(t, fiber.StatusNotFound, resp.StatusCode)

			// The response should be JSON (since we return JSON errors)
			var result map[string]interface{}
			err = json.NewDecoder(resp.Body).Decode(&result)
			require.NoError(t, err)
			assert.Contains(t, result["error"], "SAML is not configured")
		})
	}
}

// TestHandleSAMLAssertion_MissingSAMLResponse tests that missing SAMLResponse returns 400
func TestHandleSAMLAssertion_MissingSAMLResponse(t *testing.T) {
	// This test uses nil SAML service, but the SAMLResponse validation should happen first
	app := fiber.New()
	handler := NewSAMLHandler(nil, nil)
	app.Post("/auth/saml/acs", handler.HandleSAMLAssertion)

	req := httptest.NewRequest("POST", "/auth/saml/acs", nil)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := app.Test(req)
	require.NoError(t, err)
	defer resp.Body.Close()

	// Since SAML service is nil, it will return 404 first
	// This is expected behavior - service check comes before parameter validation
	assert.Equal(t, fiber.StatusNotFound, resp.StatusCode)
}

// TestSAMLProviderResponse_JSONSerialization tests that SAMLProviderResponse serializes correctly
func TestSAMLProviderResponse_JSONSerialization(t *testing.T) {
	provider := SAMLProviderResponse{
		ID:       "provider-123",
		Name:     "okta",
		EntityID: "https://okta.example.com",
		SsoURL:   "https://okta.example.com/sso",
		LoginURL: "http://localhost:8080/auth/saml/login/okta",
		Enabled:  true,
	}

	data, err := json.Marshal(provider)
	require.NoError(t, err)

	var decoded SAMLProviderResponse
	err = json.Unmarshal(data, &decoded)
	require.NoError(t, err)

	assert.Equal(t, provider.ID, decoded.ID)
	assert.Equal(t, provider.Name, decoded.Name)
	assert.Equal(t, provider.EntityID, decoded.EntityID)
	assert.Equal(t, provider.SsoURL, decoded.SsoURL)
	assert.Equal(t, provider.LoginURL, decoded.LoginURL)
	assert.Equal(t, provider.Enabled, decoded.Enabled)
}

// TestSAMLLoginResponse_JSONSerialization tests SAMLLoginResponse serialization
func TestSAMLLoginResponse_JSONSerialization(t *testing.T) {
	response := SAMLLoginResponse{
		RedirectURL: "https://idp.example.com/sso?SAMLRequest=encoded",
	}

	data, err := json.Marshal(response)
	require.NoError(t, err)

	var decoded SAMLLoginResponse
	err = json.Unmarshal(data, &decoded)
	require.NoError(t, err)

	assert.Equal(t, response.RedirectURL, decoded.RedirectURL)
}

// TestSAMLCallbackResponse_JSONSerialization tests SAMLCallbackResponse serialization
func TestSAMLCallbackResponse_JSONSerialization(t *testing.T) {
	response := SAMLCallbackResponse{
		AccessToken:  "access-token-123",
		RefreshToken: "refresh-token-456",
		ExpiresIn:    3600,
		TokenType:    "Bearer",
		User:         nil, // Can be nil
	}

	data, err := json.Marshal(response)
	require.NoError(t, err)

	var decoded SAMLCallbackResponse
	err = json.Unmarshal(data, &decoded)
	require.NoError(t, err)

	assert.Equal(t, response.AccessToken, decoded.AccessToken)
	assert.Equal(t, response.RefreshToken, decoded.RefreshToken)
	assert.Equal(t, response.ExpiresIn, decoded.ExpiresIn)
	assert.Equal(t, response.TokenType, decoded.TokenType)
	assert.Nil(t, decoded.User)
}

// NOTE: For full integration testing with real SAML assertions, database operations,
// and user creation, see the E2E tests in test/e2e/ directory.
// These unit tests focus on handler logic, error cases, and data serialization.
//
// Additional tests that should be added when implementing full SAML service:
// - Test provider filtering (app vs dashboard login)
// - Test relay state validation and redirect URL whitelisting
// - Test SAML assertion replay detection
// - Test SAML assertion expiration validation
// - Test audience mismatch detection
// - Test missing email attribute handling
// - Test auto user creation vs manual provisioning
// - Test group-based access control
// - Test SAML Single Logout (SLO) flows
